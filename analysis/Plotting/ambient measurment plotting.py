def binfileload(path, IDname=None, IDnum=None, CHnum=None, N=-1, Nstart=0):
    """
    Loads in a bin file generated by AFR

    Loads float32 single-precision, little-endian binary files without header
    information.

    This function returns NumPy datatypes, so make sure you are importing
    NumPy in your base scripts.

    Parameters
    ----------
    path : str
        The path to the file, do not include trailing separator. If the next three
        values are not input, it will assume that this is just a file you want to load.
    IDname : str, optional
        Root test name selected in AFR to save the files, e.g. 'ID'
    IDnum : int, optional
        Test number as recorded by AFR, e.g. 1
    CHnum : int, optional
        Channel number as recorded by AFR, e.g. 0
    N : int, optional
        Number of samples to read. Default is entire file.
    Nstart: int, optional
        Number of samples to offset from beginning of file. Default beginning.

    Returns
    -------
    x : ndarray of float
        The full array of data is returned

    Notes
    -------
    Author: David Van Komen (david.vankomen@gmail.com)

    Last Modified: 02/18/20

    Based on: binfileload.m by Kent Gee
    """
    import os
    from pathlib import Path
    import numpy as np
    
    if IDname == None and CHnum == None and IDnum == None:
        # we're going to use just the filename if it's ever not zero
        filename = Path(path)
        if not filename.exists():
            raise FileNotFoundError(f"The file '{filename}'' does not exist!")
    elif IDname != None and CHnum != None and IDnum != None:
        # generate the filename based on input parameters
        filename = Path(path)
        filename = filename / f"{IDname}{IDnum:03.0f}_{CHnum:03.0f}.bin"
        if not filename.exists():
            raise FileNotFoundError(
                f"The file '{str(filename)}'' governed by these inputs doesn't exist.")
    else:
        raise Exception(
            "Sorry, but if you're going to use one of the optional " +
            "filename inputs, you need to use them all.")

    # open the file as our binary file type
    with open(filename, 'rb') as binary_file:

        # fix where we start reading
        # convert Nstart to bytes instead of bits
        Nstart = Nstart * 4

        # move the binary file to where we want to start  reading
        binary_file.seek(Nstart)

        # now, we get the handle for the actual data that's left
        data = binary_file.read()

        # grab the data from the buffer
        x = np.frombuffer(data, dtype=np.float32, count=N)

        binary_file.close()
    return x
# end binfile load

def PlotAmbientNoise(date,scannum,idnum,fs):
    import numpy as np
    import matplotlib.pyplot as plt
    import sys
    sys.path.insert(1,'C:/Users/khopp/UW-Research-Files/byuarglib')
    import byuarglib as byu
    params = {'legend.fontsize': 15,
              'figure.figsize': (15, 10),
             'axes.labelsize': 24,
             'axes.titlesize':28,
             'axes.titleweight':'bold',
             'xtick.labelsize':'xx-large',
             'ytick.labelsize':'xx-large',
             'lines.linewidth':2}
    pylab.rcParams.update(params)

    scan = '_scan'+scannum
    path = 'C:/Users/khopp/Box/UW Data/Ambient Measurements/'+date+'/'+date+scan
    signal=binfileload(path + '/' + 'ID001_00' + idnum + '.bin')

    pref = 1e-6
    GXX, f, OASPL = byu.autospec(signal,fs,2**13,len(signal),pref)
    GXX_dB = 20*np.log10(np.abs(GXX/pref))
    plt.semilogx(f,GXX_dB)
    plt.xlim((10,fs/2))
    plt.xlabel('Frequency Hz')
    plt.ylabel('dB')
    plt.title('Ambient Power Spectral Density \n Panels Water Depth 0.24 m')
    plt.grid(True)
    
    return GXX,f

import numpy as np
import matplotlib.pyplot as plt

fs=600000

plt.figure()
for x in range(0,10,1):
    PlotAmbientNoise('2022-03-25','0',f'{x}',fs)